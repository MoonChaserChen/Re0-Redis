# 缓存Cache
由于Redis的并发性能比较高，因此将Redis作为数据库（比如Mysql）中数据的缓存也是非常常用的的使用方式。

通常使用方式为：先查缓存，如果缓存没有数据，查询DB。但数据的更新会使得情况更复杂。

- 读操作是否读DB，若读到DB时是否更新缓存？

- 修改时更新缓存 or 淘汰缓存？

- 修改时先修改DB还是先更新/淘汰缓存？

查询到DB时不更新缓存 & 缓存不失效 & 修改时更新缓存

1. 读操作是否读DB？
若读操作只读缓存不读DB，则需要保证缓存一直可用，且一定是存在着值的。但是缓存的定位是起一个访问提速的作用，当缓存不可用时（比如缓存down掉）是不应当影响业务的。
因此若读不到缓存时，还是应当读DB的。
2. 读DB后是否设置缓存？
设置缓存会好一些。缓存适用于读非常多的情况，因此下一次读的时候就会直接命中缓存从而不读DB，减轻DB的压力。
> 因此读操作的处理是：先查缓存，如果缓存有数据，则直接返回；如果缓存没有数据，查询DB，同时将数据置于缓存中
3. 写操作时更新缓存VS删除缓存
由于前面提到读操作"查询缓存没有数据从而查DB后会将数据置于缓存中"，因此这里写操作的时候删除缓存也是可以的，代价就是增加下一次读的cache miss。
所以这里我其实是更倾向于删除缓存，因为只要用了缓存，就会出现缓存不一致性（只能尽可能做到最终一致性），而删除缓存是清除缓存不一致性的简单而有效的手段，
以一次cache miss的代价来清除可能出现的缓存不一致性。
4. 写操作时先删缓存VS先改DB
我更倾向于"缓存延时双删"，详见"缓存一致性"
5. 考虑变更失败情况
延时双删情况：删除缓存 -> 修改DB -> 删除缓存
如果前两步失败，为了维持数据一致性，直接抛异常就好了，如果是最后一步删除缓存失败，则可以异步重试（线程或MQ）一定次数，如果一直失败，则运维报警。
> 题外话，我还没遇到过删除缓存失败的情况