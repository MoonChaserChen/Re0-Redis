# 高可用Sentinel
Sentinel（哨兵节点）可用于主从复制模式下，Master故障时Slave自动提升为Master。

## Sentinel作用
Sentinel主要有以下作用：
- 监控

    检测Master与Slave是否正常工作
- 通知

    当监控的Redis实例出现故障时，执行通知功能
- 自动化failover
    
    Master故障时Slave自动提升为Master。
- 配置中心
    
    客户端直接连接到Sentinels（避免单点故障，这里应为多个），以获取到Master地址
    
    
## 配置项
### 简单配置
```
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1
```
- sentinel monitor

    比如：`sentinel monitor mymaster 127.0.0.1 6379 2`
    1. 只需要配置master地址，slaves会自动发现，同时还需要给master取个“名称”，即这里的 `mymaster`。
被发现的slaves会被自动添加到这个配置文件中，同时当出现failover时，信息也会被记录。
    2. 当达到2个sentinel认为master故障时，其中一个sentinel将当前Master标记为故障，并尝试执行failover，
    当对这个sentinel来说有超过半数的sentinel（包括自己）可达时，将会开始执行failover
    3. 可使用 `sentinel master mymaster` 检查当前master状态
- down-after-milliseconds

    当Sentinel在超过这个时间没有收到Master的回应时，则Sentinel认为Master不可用
- parallel-syncs

    failover时，新master可同时向多少个slave进行数据同步（这个值越小，failover所花时间越多）

### 其它
- sentinel也可以监视多个Master，如：
```
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1

sentinel monitor resque 192.168.1.3 6380 4
sentinel down-after-milliseconds resque 10000
sentinel failover-timeout resque 180000
sentinel parallel-syncs resque 5
```

## 配置示例
- M: Master
- R: Replication(Slave)
- S: sentinel
- B： Box（这里可表示一个computer或VM）
### 一主两从三哨兵
```
       +-B1-+
       | M1 |
       | S1 |
       +----+
          |
+-B2-+    |    +-B3-+
| R2 |----+----| R3 |
| S2 |         | S3 |
+----+         +----+

Configuration: quorum = 2
```

#### 异常情况
- Sentinel网络分区

    当B1产生网络分区后（B1不能与B2,B3通信），S2, S3选举出新的Master，但这里S1仍认为Master为M1（同时有部分客户端C1仍认为Master为M1），
    当网络分区恢复后，M1抛弃所有数据并成为Slave（因此这段时间内C1往M1写的数据会丢失）
    可使用如下配置减轻这种情况：
    ```
    min-replicas-to-write 1
    min-replicas-max-lag 10
    ```
    在这种配置下，当B1产生网络分区，达不到 `min-replicas-to-write 1` 这个条件，因此C1无法往Master中写数据
    
### 客户端配置Sentinel
```
     +-B1-+         +-B2-+
     | M1 |----+----| R1 |
     |    |    |    |    |
     +----+    |    +----+
               |
  +------------+------------+
  |            |            |
  |            |            |
+-B3-+       +-B4-+      +-B5-+
| C1 |       | C2 |      | C3 |
| S1 |       | S2 |      | S3 |
+----+       +----+      +----+

Configuration: quorum = 2
```

## 自动发现
### 添加Sentinel
在启动一个Sentinel实例时，只需要配置需要监控的Master，这个Sentinel就会通过“自动发现”策略（在10秒内）嗅探到其它的Sentinel及Slave。
> 因此添加Sentinel时，只需要启动这个Sentinel并监控同样的Master就行了；但当需要添加多个新的Sentinel时，建议一个一个地加，
防止在添加Sentinel时发生failover。

### 移除Sentinel
由于**Sentinel会记住已发现的Sentinel（即使这个Sentinel很长时间不可达）。**
可在没有网络分区的情况下依次在每个Sentinel上执行命令：`SENTINEL RESET mastername`（注意需要等待至少三十秒再执行下一个）。最后可以通过 
`SENTINEL MASTER mastername`检查结果中的`num-other-sentinels`是否正确。

### 移除Slave
**Sentinel同样会记住已发现的Slave（即使Slave很长时间不可达）。**
同样可依次再每个Sentinel上执行命令： `SENTINEL RESET mastername`，这时Sentinel会从Master的INFO命令中获取当前的所有Slave。


## Sentinel监控
### Master状态
Master包括三种状态：正常（master）、主观下线（s_down）、客观下线（o_down）

- 主观下线

    当任一Sentinel在 `is-master-down-after-milliseconds` 内没有收到Master的回应时，将Master置为主观下线状态。
    
    Sentinel通过Ping命令去检测Master状态，可接受的回应有以下三种：
    1. +PONG
    2. -LOADING error
    3. -MASTERDOWN error
    
    当不是这三种回应时，Master将会被置于主观下线状态。
    
- 客观下线

    当超过 `quorum` 数量的Sentinel均认Master主观下线时，Master客观下线。
   
#### 主观下线与客观下线 
1. 主观下线不会触发failover
2. 客观下线会触发failover申请，但是否通过取决于“大多数原则”
3. 通过非强一致性算法实现从主观下线到客观下线状态的转变
    > Sentinel会从其它Sentinel通过 `SENTINEL is-master-down-by-addr` 命令获取Master的状态，
    当达到 `quorum` 数量的Sentinel均认为Master客观下线时，Master的状态由客观下线变为主观下线。
4. 只有Master拥有客观下线状态，Slave与Sentinel只拥有主观下线状态
    > Slave的主观下线状态的意义在于：在某个Sentinel执行failover的过程中，不会选举主观下线状态的Slave为Master


### 状态检查
命令 `sentinel master mymaster`
```
127.0.0.1:26379> sentinel master mymaster
 1) "name"
 2) "mymaster"
 3) "ip"
 4) "127.0.0.1"
 5) "port"
 6) "6379"
 7) "runid"
 8) "953ae6a589449c13ddefaee3538d356d287f509b"
 9) "flags"
10) "master"
11) "link-pending-commands"
12) "0"
13) "link-refcount"
14) "1"
15) "last-ping-sent"
16) "0"
17) "last-ok-ping-reply"
18) "735"
19) "last-ping-reply"
20) "735"
21) "down-after-milliseconds"
22) "5000"
23) "info-refresh"
24) "126"
25) "role-reported"
26) "master"
27) "role-reported-time"
28) "532439"
29) "config-epoch"
30) "1"
31) "num-slaves"
32) "2"
33) "num-other-sentinels"
34) "2"
35) "quorum"
36) "2"
37) "failover-timeout"
38) "60000"
39) "parallel-syncs"
40) "1"
```

1. num-other-sentinels

    检测到其它sentinel的数量（这里总共为3个）
2. flags

    Master状态，这里为master表示正常，异常包括：s_down or o_down 
3. num-slaves
    
    表示有两个Slave
    
4. ip和port

    表示master的地址，也可以使用 `SENTINEL get-master-addr-by-name mymaster`查命令查看
    ```
    127.0.0.1:5000> SENTINEL get-master-addr-by-name mymaster
    1) "127.0.0.1"
    2) "6379"
    ```
    
## 其它
- Sentinel应该为至少为独立的三个，主要有以下原因：
    - 当多个Sentinel认为Master不可用时，才执行failure detection
    - 避免Sentinel出现单点故障
- Redis 2.6发布了第一个版本的Sentinel（已废弃），2.8发布了第二个版本的Sentinel
- 可用redis-sentinel启动Sentinel `redis-sentinel /path/to/sentinel.conf`，其中配置文件为必须项且可写
（Sentinel会将当前状态信息修改到这个配置文件中）
- Sentinel默认使用TCP端口26379
- 由于Redis采用异步复制，因此Sentinel + Redis这种高可用也并不能保证failover后数据不丢失，参考：[主从复制数据一致性](/4-Redis深入/4.8-主从复制.md#数据一致性问题)
    1. 原Master的操作记录还并未同步到提升为Master的Slave节点
    2. 原Master与Slave之间产生网络分区（需要一定时间才能确定网络分区的产生），Master的操作记录无法同步到Slave
- 客户端也应该支持Sentinel
- 可在Sentinel运行时使用 `SENTINEL SET` 命令修改Sentinel相关配置
