# 事务
Redis事务含义如下：

` 所有事务中的命令命令要么全部不执行，要么全部执行且按顺序执行且中间不会穿插来自其它客户端的命令 `

同时Redis的事务也有以下特点：
- 不支持回滚
- 事务中的命令会被写到AOF文件中，若在写入的过程中Redis server崩溃，则再次启动时会失败并检查到这一错误，可使用 _redis-check-aof_ 修复（移除不完整的事务）。
（这时AOF文件与Redis中数据一致吗？）
- 执行MULTI后，所有命令并不直接执行，而是用一个队列缓存起来（这时命令的返回结果为：QUEUED），等EXEC命令统一执行并返回所有结果（与之前命令顺序保持一致）。

## 事务中的错误
事务中的错误可分两类：执行EXEC之前报错、执行EXEC之后报错
### 执行EXEC之前报错
比如命令语法错误、内存不足
客户端均能感知到这个错误（成功将命令缓存到队列时将会返回：QUEUED），因此通常客户端遇到这个错误会使用DISCARD抛弃事务。

从Redis2.6.5开始，服务端也会记录这个错误信息，因此即使客户端遇到这类错误后仍然执行EXEC命令，服务端也会抛出异常并抛弃事务。
这样客户端就可以不关注开启事务后执行命令的返回值是不是QUEUED了，直接使用管道将事务中所有命令一次性发给服务端，减少RTT（Round Trip Time）。
关于Jedis如何使用pipeline来实现transaction，可参照：[利用WATCH实现INCR](/7-其它/7.2-利用WATCH实现INCR.md#错误实现)
### 执行EXEC之后报错
比如对一个非数字的String使用INCR命令

## 相关命令
| 命令 | 含义 |
| ---- | ---- |
| MULTI | 开启事务，开启后所有命令会添加到缓存队列 |
| EXEC | 执行缓存队列的所有命令并返回结果 |
| DISCARD | 抛弃缓存队列中的所有命令并退出事务 |
| WATCH | 监控某个K-V，参见[WATCH](#WATCH) |
| UNWATCH | 去除所有K-V的监控 |

### WATCH
用在MULTI前面以监视一个或多个K-V，当任意一个监视K-V在当前事务执行EXEC前被非当前事务修改后，自动执行DISCARD以抛弃事务（这个命令可用来做CAS操作）
- “非当前事务”包括当前Client的“watch-set-multi-exec”（这里的set命令不在事务中，会导致事务失败），
但不包括当前Client的“watch-multi-set-exec”（这里的set命令在事务中，不影响事务的正常执行）
- 当被WATCH的K-V因为TTL过期时，不会触发DISCARD
- EXEC、DISCARD命令会自动UNWATCH之前WATCH的K-V

### 不支持回滚？
由[事务中的错误](#事务中的错误)可知，在执行EXEC之前报错是会抛弃事务的，达到类似“回滚”的效果；但在执行EXEC之后报错并不会回滚，后续命令依然会顺利执行下去。

#### Redis为什么不支持回滚
- Redis中的错误应当在生产环境之前检查出来。（语法参数个数错误应由客户端避免；参数类型错误可在测试阶段发现）
- Redis设计为简单、快速，因此没有必要实现Roll back。
