# 消息队列
典型的生产者-消费者模式是生产者用于产生数据（或称为消息），放到消息队列中，消费者从消息队列中去取消息进行消费。
## 简单实现
而Redis的List数据类型则可以充当这里的消息队列。

而这首先带来的一个考虑就是：先从消息队列中取走再消费还是先成功消费再从消息队列中取走？

- 先取走再消费

    可能问题：消息丢失。
    
    1. 取走后由于网络波动导致消费者没有收到消息，导致消息丢失
    2. 消息取走后在进行消费之前消费者崩溃，导致消息丢失
    2. 消息取走后在消费失败（消息本身无异常，其它原因导致），导致消息丢失
    
- 先成功消费再取走

    可能问题：消息堆积、重复消费
    
    1. 消费完成后再取走时，由于网络波动，未成功取走，导致重复消费
    2. 某个消息一直消费失败（异常消息或其它原因），一直未能取走，导致消息堆积。
    
## 使用RPOPLPUSH实现
> 包括RPOPLPUSH、LPOPRPUSH、BRPOPLPUSH、BLPOPRPUSH。这里以RPOPLPUSH为例。

`RPOPLPUSH mylist myotherlist`操作含义为：从mylist中右弹出元素放入myotherlist的左侧，并返回该元素。

这样就有一种可靠的队列实现方式：

消息存放于`store-list`中，消费时使用`RPOPLPUSH store-list processing-list`弹出将要消费的元素，并同时将这个元素保存到`processing-list`中，
`processing-list`表示正在处理的元素，等成功消费后，再从`processing-list`中使用`LREM`移除元素（虽然`LREM`的时间复杂度为O(N+M)，
但实际上`processing-list`中元素并不多，因此移除效率还可以）。同时可根据启动新的流程去对`processing-list`中存留太久的消息进行处理。

可能问题：

- 对`processing-list`进行处理

在对`processing-list`中存留太久的消息进行处理时，又回到了最开始的情况（先取走再消费，还是先成功消费再取走）。这里可干脆不使用“取走+消费”这种处理方式了，直接将其转移到`store-list`中接着处理。

- “存留太久”的判断

需要给予这个“存留太久”的判定设置足够长的时间，以防止某个消息其实正在处理（只不过处理的时间较长来不及`LREM`移除），从而最终导致重复消费。【无法绝对保证】【如何判断存留时间】

- `LREM`移除时失败

`LREM`移除时失败，导致已成功消费的消息仍存留于`processing-list`中。因此在对`processing-list`中存留信息进行处理时，可根据业务判断当前消息是否已处理过。【判断不了怎么办？】