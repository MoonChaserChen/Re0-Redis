# 缓存问题
## 缓存穿透
### 什么是缓存穿透？
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。
如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统（比如DB）造成很大的压力。这就叫做缓存穿透。

试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。
 
### 如何避免？
1. 查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
2. 使用BloomFilter对一定不存在的key进行过滤。参见[Bitmap](/3-Redis使用/3.8-Bitmap.md)

    > 1. 把所有的可能存在的key通过N个Hash算法映射到Bitmap中。
    > 2. 在查询的时候先去Bitmap中进行验证Key是否存在（Key通过任意一个Hash算法在Bitmap中不存在对应映射，则Key不存在），
    如果不存在就直接返回，存在再走查缓存 -> 查 DB
    > 3. 如果数据库中数据进行了更新的同时也需要更新布隆过滤器）
 
## 缓存击穿   
### 什么是缓存击穿?
缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，
就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。
### 会带来什么问题?
会造成某一时刻数据库请求量过大，压力剧增。
### 如何解决?
上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。
其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。

## 缓存雪崩
###什么是缓存雪崩？
当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
###如何避免？
1. 为热点数据做预热处理（提前缓存）。
1. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
2. 使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。
2. 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
3. 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期（此点为补充）
4. 使用集群缓存，保证缓存服务的高可用
5. 使用本地缓存 ehcache。ehcache作为本地缓存，是可以共用的，即一个地方存，另一个地方可以直接使用。
使用流程一般是：先从本地缓存ehcache中取，取不到再从网络缓存redis里取，再取不到就从DB里取，中间每一步如果取到了，就将值set到对应的存储容器里，
以便下次就可以直接获取到。


